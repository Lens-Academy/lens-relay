# Architecture

**Analysis Date:** 2026-02-08

## Pattern Overview

**Overall:** Layered client-server CRDT (Conflict-free Replicated Data Type) architecture with WebSocket real-time sync and document-centric collaboration.

**Key Characteristics:**
- CRDT-based state management (Yjs) for conflict resolution without centralized coordination
- WebSocket-driven real-time synchronization between clients and server
- Token-based authentication with HMAC (RFC 8949 CWT/CBOR) support
- Multi-folder metadata tracking for Obsidian vault integration
- File attachment handling via S3/R2 presigned URLs
- Event-driven webhook dispatch for document changes
- In-memory document cache with persistent storage to S3/filesystem

## Layers

**Client (Web Editor):**
- Purpose: Browser-based collaborative editor for Relay documents
- Location: `lens-editor/src/`
- Contains: React components, CodeMirror editor, Yjs document binding, metadata management
- Depends on: `@y-sweet/client` (YSweetProvider), `@y-sweet/react` (hooks), `yjs`, CodeMirror
- Used by: End users; syncs with relay-server via WebSocket

**Relay Server (Rust/Axum):**
- Purpose: CRDT synchronization server, document persistence, authentication, file handling
- Location: `crates/relay/src/`
- Contains: HTTP API routes, WebSocket handlers, document management, file operations
- Depends on: `y-sweet-core`, Axum web framework, tokio async runtime
- Used by: Web clients, Python SDK, external webhooks

**Core CRDT & Auth (Rust Library):**
- Purpose: Shared CRDT operations, authentication logic, storage abstraction, metrics
- Location: `crates/y-sweet-core/src/`
- Contains: Document sync, auth (CWT tokens), store interface, event dispatch, link indexing
- Depends on: `yrs` (Rust implementation of Yjs), `serde`, crypto primitives
- Used by: Relay server, Y-sweet worker (Cloudflare)

**Python SDK:**
- Purpose: Server-to-server programmatic access to Relay documents
- Location: `python/src/relay_sdk/`
- Contains: DocumentManager class, token fetching, document update mechanisms
- Depends on: `requests`
- Used by: External automation, batch operations

**Debugger (Next.js):**
- Purpose: Development tool for inspecting Yjs document state in browser
- Location: `debugger/src/`
- Contains: Y.Doc visualization, awareness state inspection
- Depends on: `@y-sweet/sdk`, `@y-sweet/react`
- Used by: Developers during development/debugging

## Data Flow

**Document Creation:**
1. Client calls `/doc/new` (POST) with optional docId
2. Relay-server creates Y.Doc in-memory, stores document metadata
3. Client receives docId, calls `/doc/{docId}/auth` to get WebSocket URL + token
4. Client connects to WebSocket at `/d/{docId}/ws/{docId}`, passes token in URL

**Real-Time Sync (WebSocket):**
1. Client establishes WebSocket connection with auth token
2. Server decodes token, creates DocConnection for client
3. Client sends Y.Sync protocol messages (state vector, updates)
4. Server sends accumulated updates back via same channel
5. Multiple clients converge on shared state via CRDT merge
6. Server persists updates to S3/filesystem periodically

**Metadata Management (Folder Documents):**
1. Folder document ID contains relay-server-id prefix
2. Folder Y.Doc has two maps: `filemeta_v0` (modern) and `docs` (legacy)
3. Each markdown document has entry in both maps (Obsidian compatibility)
4. Client metadata hook watches for changes, reconstructs file tree
5. Changes sync bidirectionally via WebSocket

**File Attachment Upload:**
1. Client requests presigned upload URL from `/f/{doc_id}/upload-url` (POST)
2. Server generates S3/R2 presigned URL, returns to client
3. Client uploads file directly to S3/R2 bucket
4. Client stores file hash in Y.Doc as metadata
5. Server can serve downloads via `/f/{doc_id}/download` or presigned R2 URL

**Authentication:**
1. Server token (embedded in client JS): HMAC-signed JWT with server key
2. Client token: Generated by relay-server via `/doc/{docId}/auth` endpoint
3. Token validation: Verify HMAC signature using public key from relay.toml
4. Auto-detect key type (legacy ECDSA P-256 or Ed25519) via token header
5. Expiration: Tokens default to 1 day (86400 seconds), configurable

**State Management:**
- **In-Memory:** DashMap<docId, Arc<DocWithSyncKv>> holds all active documents
- **Persistence:** Periodic worker (default 30s) snapshots updates to S3/filesystem
- **Key-Value Store:** SyncKv layer provides get/set for non-document state
- **Webhook Events:** DocumentUpdatedEvent dispatched on each Y.Sync message received
- **Metrics:** Prometheus metrics track auth failures, permission denials, latency

## Key Abstractions

**Document (Y.Doc):**
- Purpose: Root collaborative data structure containing all shared state
- Examples: `crates/y-sweet-core/src/doc_sync.rs` (DocWithSyncKv), Yjs Y.Doc in client
- Pattern: CRDT mapping of keys to values; changes are conflict-free updates

**Store Trait:**
- Purpose: Pluggable persistence backend
- Examples: `crates/y-sweet-core/src/store/mod.rs`, `crates/y-sweet-core/src/store/s3.rs`
- Pattern: Async read/write/delete operations; filesystem, S3, and in-memory implementations

**Authenticator:**
- Purpose: Token generation and verification
- Examples: `crates/y-sweet-core/src/auth.rs`
- Pattern: CWT/CBOR token signing with public/private keys; audience/scope validation

**EventDispatcher:**
- Purpose: Multiplex document updates to webhooks, metrics, backlinks
- Examples: `crates/y-sweet-core/src/event.rs`
- Pattern: Event channels for sync protocol, document updates, file changes

**LinkIndexer:**
- Purpose: Extract wikilinks from markdown, track backlinks
- Examples: `crates/y-sweet-core/src/link_indexer.rs`, `lens-editor/src/lib/link-extractor.ts`
- Pattern: Scan document contents for `[[link]]` patterns, maintain reverse index

## Entry Points

**Relay Server (Rust):**
- Location: `crates/relay/src/main.rs`
- Triggers: `cargo run --bin relay -- serve --config relay.toml` or Docker startup
- Responsibilities: Parse CLI, load config/auth keys, start Axum router, listen on port

**Web Editor (Browser):**
- Location: `lens-editor/src/main.tsx`
- Triggers: Browser navigation to editor URL
- Responsibilities: Mount React app, initialize folder metadata, create RelayProvider

**Setup Script (Node.js):**
- Location: `lens-editor/scripts/setup-local-relay.mjs`
- Triggers: `npm run relay:setup`
- Responsibilities: Create test documents, initialize folder metadata for local dev

## Error Handling

**Strategy:** Layered error recovery with user-facing disconnection modal

**Patterns:**
- `AppError(StatusCode, anyhow::Error)` in relay-server for HTTP responses
- `RelayServerError` in Python SDK for API failures
- `DisconnectionModal` in lens-editor detects WebSocket close, shows reconnect UI
- Sync failures logged with tracing; metrics recorded for observability
- Webhook delivery failures retried async; failed deliveries trigger metrics

## Cross-Cutting Concerns

**Logging:** Tracing crate with `tracing-subscriber` for structured logs; env-based filtering via `RUST_LOG`

**Validation:**
- Doc ID validation: UUID format only
- File hash validation: SHA256 hex strings
- Document name validation: Non-empty, length limits
- Token expiration: Epoch milliseconds, server compares to current time

**Authentication:**
- CWT/CBOR token format with HMAC-SHA256 signature
- Public keys loaded from `relay.toml` or environment variables
- Per-document authorization: Permission enum (Doc, File, Admin scope)
- Service account support: Server token embedded in JS for server-initiated operations

**Rate Limiting:** Not implemented; relies on upstream Cloudflare Tunnel or nginx

**CORS:** Vite dev server proxy (`/api/relay` â†’ `http://localhost:8090`) avoids CORS in development; production uses Cloudflare subdomain

---

*Architecture analysis: 2026-02-08*
