---
phase: 01-bridge-history-display
plan: 03
type: tdd
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx
  - lens-editor/src/components/DiscussionPanel/DiscussionPanel.test.tsx
  - lens-editor/src/components/DiscussionPanel/DiscussionPanel.integration.test.tsx
  - lens-editor/src/components/DiscussionPanel/MessageList.tsx
  - lens-editor/src/components/DiscussionPanel/MessageItem.tsx
  - lens-editor/src/components/DiscussionPanel/useDiscussion.ts
  - lens-editor/src/components/DiscussionPanel/useMessages.ts
  - lens-editor/src/components/DiscussionPanel/index.ts
  - lens-editor/src/components/Layout/EditorArea.tsx
autonomous: false

must_haves:
  truths:
    - "User opens a document with `discussion` frontmatter and sees a chat panel to the right of the existing sidebar"
    - "Panel shows loading spinner while fetching messages"
    - "Panel displays the last 50 messages with author username, avatar image, and timestamp"
    - "Channel name appears as the panel header"
    - "Documents without a `discussion` field show no chat panel (no extra sidebar)"
    - "Consecutive messages from the same author within 5 minutes are visually grouped"
  artifacts:
    - path: "lens-editor/src/components/DiscussionPanel/DiscussionPanel.test.tsx"
      provides: "DOM-level unit tests using real fixtures and mocked fetch"
      min_lines: 100
    - path: "lens-editor/src/components/DiscussionPanel/DiscussionPanel.integration.test.tsx"
      provides: "Integration smoke test against real Discord API (gated by env var)"
      min_lines: 30
    - path: "lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx"
      provides: "Main panel component that conditionally renders based on discussion frontmatter"
      min_lines: 40
    - path: "lens-editor/src/components/DiscussionPanel/MessageList.tsx"
      provides: "Scrollable message list component"
      min_lines: 20
    - path: "lens-editor/src/components/DiscussionPanel/MessageItem.tsx"
      provides: "Single message with avatar, username, timestamp"
      min_lines: 30
    - path: "lens-editor/src/components/DiscussionPanel/useDiscussion.ts"
      provides: "Hook: extracts discussion channel ID from Y.Doc text"
      exports: ["useDiscussion"]
    - path: "lens-editor/src/components/DiscussionPanel/useMessages.ts"
      provides: "Hook: fetches messages from proxy API"
      exports: ["useMessages"]
    - path: "lens-editor/src/components/Layout/EditorArea.tsx"
      provides: "Integration point for DiscussionPanel"
      contains: "DiscussionPanel"
  key_links:
    - from: "lens-editor/src/components/DiscussionPanel/useDiscussion.ts"
      to: "lens-editor/src/lib/frontmatter.ts"
      via: "import extractFrontmatter"
      pattern: "extractFrontmatter"
    - from: "lens-editor/src/components/DiscussionPanel/useDiscussion.ts"
      to: "lens-editor/src/lib/discord-url.ts"
      via: "import parseDiscordUrl"
      pattern: "parseDiscordUrl"
    - from: "lens-editor/src/components/DiscussionPanel/useMessages.ts"
      to: "/api/discord/channels/:channelId/messages"
      via: "fetch call to Vite proxy"
      pattern: "fetch.*api/discord"
    - from: "lens-editor/src/components/DiscussionPanel/MessageItem.tsx"
      to: "lens-editor/src/lib/discord-avatar.ts"
      via: "import getAvatarUrl"
      pattern: "getAvatarUrl"
    - from: "lens-editor/src/components/DiscussionPanel/MessageItem.tsx"
      to: "lens-editor/src/lib/format-timestamp.ts"
      via: "import formatTimestamp"
      pattern: "formatTimestamp"
    - from: "lens-editor/src/components/Layout/EditorArea.tsx"
      to: "lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx"
      via: "import and render DiscussionPanel"
      pattern: "DiscussionPanel"
---

<objective>
Build the DiscussionPanel React component with TDD: write DOM-level tests first using real Discord fixture data, then implement components to pass them, then integrate into EditorArea.

Purpose: TDD ensures the component correctly handles real Discord data shapes (not guessed mocks), verifies all rendering paths (loading, error, empty, messages, grouping), and catches regressions before manual verification.

Output: A fully tested DiscussionPanel component with unit tests, an integration smoke test, and integration into EditorArea.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bridge-history-display/01-CONTEXT.md
@.planning/phases/01-bridge-history-display/01-RESEARCH.md
@.planning/phases/01-bridge-history-display/01-01-SUMMARY.md
@.planning/phases/01-bridge-history-display/01-02-SUMMARY.md
@lens-editor/src/components/Layout/EditorArea.tsx
@lens-editor/src/components/BacklinksPanel/BacklinksPanel.tsx
@lens-editor/src/components/CommentsPanel/CommentsPanel.tsx
@lens-editor/src/components/CommentsPanel/CommentsPanel.test.tsx
@lens-editor/src/lib/frontmatter.ts
@lens-editor/src/lib/discord-url.ts
@lens-editor/src/lib/discord-avatar.ts
@lens-editor/src/lib/format-timestamp.ts
@lens-editor/src/components/DiscussionPanel/__fixtures__/discord-messages.json
@lens-editor/src/components/DiscussionPanel/__fixtures__/discord-channel.json
@lens-editor/vitest.config.ts
@lens-editor/src/test/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing DiscussionPanel tests using real fixtures (RED)</name>
  <files>
    lens-editor/src/components/DiscussionPanel/DiscussionPanel.test.tsx
    lens-editor/src/components/DiscussionPanel/DiscussionPanel.integration.test.tsx
    lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx
    lens-editor/src/components/DiscussionPanel/useDiscussion.ts
    lens-editor/src/components/DiscussionPanel/useMessages.ts
    lens-editor/src/components/DiscussionPanel/index.ts
  </files>
  <action>
    Write all test files FIRST. Create minimal stub files so the tests can import and run (but fail).

    **1. Create stub source files (just enough to import, not enough to pass):**

    `useDiscussion.ts` -- stub:
    ```typescript
    export function useDiscussion() {
      return { channelId: null as string | null, guildId: null as string | null };
    }
    ```

    `useMessages.ts` -- stub:
    ```typescript
    export interface DiscordUser {
      id: string; username: string; global_name: string | null; avatar: string | null;
    }
    export interface DiscordMessage {
      id: string; content: string; author: DiscordUser; timestamp: string; type: number;
    }
    export interface DiscordChannel {
      id: string; name: string; type: number;
    }
    export function useMessages(_channelId: string | null) {
      return { messages: [] as DiscordMessage[], channelName: null as string | null, loading: false, error: null as string | null, refetch: () => {} };
    }
    ```

    `DiscussionPanel.tsx` -- stub:
    ```typescript
    export function DiscussionPanel() { return null; }
    ```

    `index.ts` -- barrel:
    ```typescript
    export { DiscussionPanel } from './DiscussionPanel';
    ```

    **2. Create `DiscussionPanel.test.tsx`:**

    ```
    /**
     * @vitest-environment happy-dom
     */
    ```

    This file mocks at TWO boundaries only:
    - `globalThis.fetch` (via `vi.stubGlobal('fetch', ...)`) -- to return fixture data instead of hitting the network
    - Y.Doc context (via a wrapper component that provides a Y.Doc with known frontmatter text)

    Everything else runs REAL: real hooks (`useDiscussion`, `useMessages`), real utilities (`extractFrontmatter`, `parseDiscordUrl`, `getAvatarUrl`, `formatTimestamp`), real React components.

    **Setup pattern for Y.Doc mock:**
    Create a test helper that wraps the component with a mock YDocProvider. The `useYDoc` hook from `@y-sweet/react` needs to return a Y.Doc. Create a real `Y.Doc`, set its `getText('contents')` to markdown with frontmatter, and provide it via a React context wrapper. Look at how the project mocks YDocProvider in existing tests, or create a minimal wrapper:
    ```typescript
    import * as Y from 'yjs';
    import { vi } from 'vitest';

    // Mock @y-sweet/react's useYDoc to return our test Y.Doc
    function createTestDoc(markdownContent: string): Y.Doc {
      const doc = new Y.Doc();
      doc.getText('contents').insert(0, markdownContent);
      return doc;
    }
    ```
    Use `vi.mock('@y-sweet/react', ...)` to make `useYDoc()` return the test doc.

    **Setup pattern for fetch mock:**
    Load the REAL fixture files:
    ```typescript
    import messagesFixture from './__fixtures__/discord-messages.json';
    import channelFixture from './__fixtures__/discord-channel.json';
    ```

    Mock fetch to return different responses based on URL:
    ```typescript
    vi.stubGlobal('fetch', vi.fn((url: string) => {
      if (url.includes('/messages')) {
        return Promise.resolve(new Response(JSON.stringify(messagesFixture), { status: 200 }));
      }
      if (url.match(/\/api\/discord\/channels\/\d+$/)) {
        return Promise.resolve(new Response(JSON.stringify(channelFixture), { status: 200 }));
      }
      return Promise.resolve(new Response('Not found', { status: 404 }));
    }));
    ```

    **Test cases (all should FAIL in RED phase because components are stubs):**

    `describe('DiscussionPanel - with discussion frontmatter')`:
    - Setup: Y.Doc with `---\ndiscussion: https://discord.com/channels/123/456\n---\nSome content`
    - "renders message text from fixture data" -- `await waitFor(() => expect(screen.getByText(messagesFixture[0].content)).toBeInTheDocument())`
      (Use the actual content string from the first message in the fixture. If the content contains markdown/special chars, use a partial text matcher.)
    - "renders usernames" -- check that `author.global_name || author.username` from fixture appears in DOM
    - "renders avatar images with correct src" -- find `<img>` elements, check `src` contains the expected CDN URL from `getAvatarUrl(author.id, author.avatar)`
    - "renders formatted timestamps" -- check that timestamps render (use regex `/ago|just now|Jan|Feb|Mar|.../` to match formatted output)
    - "renders channel name in header" -- `expect(screen.getByText('#' + channelFixture.name)).toBeInTheDocument()` (or just the channel name)
    - "groups consecutive messages from same author" -- find message items, verify that some have avatars hidden (grouped). Count avatar images vs total messages; if messages from same author exist consecutively, avatar count < message count.
    - "shows loading state before messages arrive" -- render with a fetch that returns a delayed promise, check for spinner/loading indicator before it resolves

    `describe('DiscussionPanel - without discussion frontmatter')`:
    - Setup: Y.Doc with `---\ntitle: No Discussion\n---\nJust content` (no `discussion` field)
    - "renders nothing when no discussion field" -- `expect(container.innerHTML).toBe('')` or `expect(screen.queryByRole('complementary')).not.toBeInTheDocument()`

    `describe('DiscussionPanel - error states')`:
    - "shows error message when fetch fails" -- mock fetch to return 500, check error text appears
    - "shows retry button on error" -- check for a button with "Retry" text
    - "retries fetch when retry button clicked" -- click retry, verify fetch was called again

    `describe('DiscussionPanel - empty channel')`:
    - Mock fetch to return empty array `[]`
    - "shows empty state message" -- check for "No messages" or similar text

    **3. Create `DiscussionPanel.integration.test.tsx`:**

    ```
    /**
     * @vitest-environment happy-dom
     */
    ```

    This file makes REAL API calls to the running discord-bridge sidecar. Gated by env var:
    ```typescript
    import { describe, it, expect } from 'vitest';

    const CHANNEL_ID = process.env.DISCORD_TEST_CHANNEL_ID;

    describe.skipIf(!process.env.DISCORD_BOT_TOKEN || !CHANNEL_ID)(
      'DiscussionPanel integration (live Discord)',
      () => {
        const BRIDGE_URL = process.env.DISCORD_BRIDGE_URL || 'http://localhost:8091';

        it('fetches messages with expected structure', async () => {
          const res = await fetch(`${BRIDGE_URL}/api/channels/${CHANNEL_ID}/messages?limit=10`);
          expect(res.ok).toBe(true);
          const messages = await res.json();

          // Structural invariants (not exact content)
          expect(messages.length).toBeGreaterThan(0);

          for (const msg of messages) {
            expect(msg).toHaveProperty('id');
            expect(msg).toHaveProperty('content');
            expect(msg).toHaveProperty('timestamp');
            expect(msg.author).toHaveProperty('id');
            expect(msg.author).toHaveProperty('username');
            expect(msg.author).toHaveProperty('avatar');
          }

          // Chronological order check (Discord returns newest first, sidecar may reverse)
          // Just verify timestamps are parseable
          for (const msg of messages) {
            expect(new Date(msg.timestamp).getTime()).not.toBeNaN();
          }
        });

        it('fetches channel info with expected structure', async () => {
          const res = await fetch(`${BRIDGE_URL}/api/channels/${CHANNEL_ID}`);
          expect(res.ok).toBe(true);
          const channel = await res.json();

          expect(channel).toHaveProperty('id', CHANNEL_ID);
          expect(channel).toHaveProperty('name');
          expect(typeof channel.name).toBe('string');
          expect(channel.name.length).toBeGreaterThan(0);
        });
      }
    );
    ```

    4. Run all tests to confirm they FAIL (RED phase):
       ```bash
       cd lens-editor && npx vitest run src/components/DiscussionPanel/DiscussionPanel.test.tsx
       ```
       The unit tests MUST fail because DiscussionPanel is a stub returning null.
       The integration tests should be SKIPPED (no env var set in CI/local default).
  </action>
  <verify>
    ```bash
    # Test files exist
    ls -la lens-editor/src/components/DiscussionPanel/DiscussionPanel.test.tsx
    ls -la lens-editor/src/components/DiscussionPanel/DiscussionPanel.integration.test.tsx

    # Unit tests run and FAIL (RED phase)
    cd lens-editor && npx vitest run src/components/DiscussionPanel/DiscussionPanel.test.tsx 2>&1 | tail -20
    # Should show failures (components are stubs)

    # Integration tests are SKIPPED (no env var)
    cd lens-editor && npx vitest run src/components/DiscussionPanel/DiscussionPanel.integration.test.tsx 2>&1 | tail -10
    ```
  </verify>
  <done>Test files exist with comprehensive test cases covering messages, avatars, timestamps, grouping, loading, error, empty, and conditional rendering. All unit tests FAIL because components are stubs. Integration tests are skipped (gated by env var). RED phase complete.</done>
</task>

<task type="auto">
  <name>Task 2: Implement hooks and components to pass all tests (GREEN)</name>
  <files>
    lens-editor/src/components/DiscussionPanel/useDiscussion.ts
    lens-editor/src/components/DiscussionPanel/useMessages.ts
    lens-editor/src/components/DiscussionPanel/MessageItem.tsx
    lens-editor/src/components/DiscussionPanel/MessageList.tsx
    lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx
    lens-editor/src/components/DiscussionPanel/index.ts
    lens-editor/src/components/Layout/EditorArea.tsx
  </files>
  <action>
    Replace stubs with real implementations. Make all tests pass.

    **1. Implement `useDiscussion.ts`:**
    - Import `useState`, `useEffect` from React
    - Import `useYDoc` from `@y-sweet/react`
    - Import `extractFrontmatter` from `../../lib/frontmatter`
    - Import `parseDiscordUrl` from `../../lib/discord-url`
    - Export `useDiscussion()` hook returning `{ channelId: string | null, guildId: string | null }`
    - Get ydoc via `useYDoc()`, get Y.Text via `ydoc.getText('contents')`
    - On mount and on Y.Text observe, extract frontmatter and parse discord URL
    - Debounce: only re-parse if first 500 chars change (frontmatter is at top)
    - Clean up observer on unmount
    - Return `{ channelId, guildId }` -- both null if no discussion field or invalid URL

    **2. Implement `useMessages.ts`:**
    - Keep the type exports (DiscordUser, DiscordMessage, DiscordChannel) from the stub
    - When `channelId` changes (and is not null):
      - Set `loading: true`, `error: null`
      - Fetch messages: `fetch(\`/api/discord/channels/${channelId}/messages?limit=50\`)`
      - Fetch channel info: `fetch(\`/api/discord/channels/${channelId}\`)` (in parallel)
      - On success: set messages (reverse array -- Discord returns newest first, we want oldest first), set channelName, set `loading: false`
      - On error: set `error` to descriptive message, set `loading: false`
      - Handle 429: set error to "Rate limited, try again in X seconds"
      - Handle network errors: set error to "Could not connect to Discord bridge"
    - When `channelId` is null: reset all state
    - Use AbortController for fetch cleanup on unmount or channelId change
    - Return `{ messages, channelName, loading, error, refetch }`

    **3. Implement `MessageItem.tsx`:**
    - Import `getAvatarUrl` from `../../lib/discord-avatar`
    - Import `formatTimestamp` from `../../lib/format-timestamp`
    - Import `DiscordMessage` type from `./useMessages`
    - Props: `{ message: DiscordMessage, showHeader: boolean }`
    - When `showHeader` true: avatar img (32px, rounded-full), display name (`global_name || username`), timestamp
    - When `showHeader` false: just content with left padding
    - Content: `<p>` with `whitespace-pre-wrap`
    - Avatar: `<img src={getAvatarUrl(author.id, author.avatar, 64)} alt={displayName} loading="lazy" />`
    - Timestamp: `formatTimestamp(message.timestamp)`
    - Tailwind classes matching existing design system

    **4. Implement `MessageList.tsx`:**
    - Props: `{ messages: DiscordMessage[] }`
    - Grouping: consecutive messages from same author within 5 minutes show `showHeader=false`
    - Scrollable with `overflow-y-auto flex-1`
    - Empty state: "No messages yet"
    - Scroll to bottom on initial render

    **5. Implement `DiscussionPanel.tsx`:**
    - Call `useDiscussion()` to get channelId
    - Call `useMessages(channelId)` to get messages, channelName, loading, error, refetch
    - If channelId is null: return null
    - Otherwise render: `w-80 flex-shrink-0 border-l border-gray-200 bg-white flex flex-col`
    - Header: `#channel-name`
    - Loading: spinner while loading and no messages
    - Error: message + "Retry" button calling refetch
    - Messages: `<MessageList messages={messages} />`

    **6. Update `index.ts`** barrel export (already correct from stub).

    **7. Integrate into `EditorArea.tsx`:**
    - Import `DiscussionPanel` from `../DiscussionPanel`
    - Add `<DiscussionPanel />` after the existing `<aside>` element as a sibling
    - No props needed -- reads Y.Doc from context, returns null when no discussion field

    **8. Run tests:**
    ```bash
    # New unit tests should now PASS
    cd lens-editor && npx vitest run src/components/DiscussionPanel/DiscussionPanel.test.tsx

    # Existing tests should not regress
    cd lens-editor && npx vitest run

    # Build should succeed
    cd lens-editor && npx vite build 2>&1 | tail -5
    ```
  </action>
  <verify>
    ```bash
    # All DiscussionPanel unit tests pass
    cd lens-editor && npx vitest run src/components/DiscussionPanel/DiscussionPanel.test.tsx

    # TypeScript compiles clean
    cd lens-editor && npx tsc --noEmit

    # Full test suite passes (no regressions)
    cd lens-editor && npx vitest run

    # Build succeeds
    cd lens-editor && npx vite build 2>&1 | tail -5
    ```
  </verify>
  <done>All DiscussionPanel unit tests pass. Components implement loading, error, empty, and message states. Messages render with avatars, usernames, timestamps, and grouping. Panel integrates into EditorArea. No regressions. GREEN phase complete.</done>
</task>

<task type="auto">
  <name>Task 3: Refactor if needed (REFACTOR)</name>
  <files>
    lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx
    lens-editor/src/components/DiscussionPanel/MessageList.tsx
    lens-editor/src/components/DiscussionPanel/MessageItem.tsx
    lens-editor/src/components/DiscussionPanel/useDiscussion.ts
    lens-editor/src/components/DiscussionPanel/useMessages.ts
  </files>
  <action>
    Review the GREEN implementation for obvious cleanup opportunities:

    - Extract any duplicated logic (e.g., display name computation used in multiple places)
    - Ensure consistent Tailwind class patterns with existing panels (BacklinksPanel, CommentsPanel)
    - Check for unnecessary re-renders (memoize expensive computations if applicable)
    - Verify error messages are user-friendly, not raw error strings
    - Ensure the panel's visual weight is balanced with the existing sidebar

    **Only refactor if there are clear improvements. Do NOT refactor for the sake of it.**

    After any changes:
    ```bash
    cd lens-editor && npx vitest run src/components/DiscussionPanel/DiscussionPanel.test.tsx
    cd lens-editor && npx vitest run
    ```

    If no refactoring needed, skip this task (mark as done with "No refactoring needed").
  </action>
  <verify>
    ```bash
    # Tests still pass after refactoring
    cd lens-editor && npx vitest run src/components/DiscussionPanel/DiscussionPanel.test.tsx
    cd lens-editor && npx vitest run
    ```
  </verify>
  <done>Code reviewed and cleaned up (or no refactoring needed). All tests still pass. REFACTOR phase complete.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1 deliverable: the Discord Discussion Panel, built with TDD.

    When a document has `discussion: https://discord.com/channels/GUILD/CHANNEL` in its frontmatter:
    - A chat panel appears to the right of the existing sidebar
    - Shows the channel name as header
    - Displays the last 50 messages with avatars, usernames, and timestamps
    - Consecutive messages from the same author are grouped
    - Loading spinner shown while fetching
    - Error state with retry button on failure
    - Documents without `discussion` field show no panel

    Test coverage:
    - Unit tests in DiscussionPanel.test.tsx using real Discord fixture data
    - Integration smoke test in DiscussionPanel.integration.test.tsx (gated by env var)
  </what-built>
  <how-to-verify>
    **Prerequisites:**
    - Discord bridge running: `cd discord-bridge && DISCORD_BOT_TOKEN=your-token npm run dev`
    - Local relay running: `cd lens-editor && npm run relay:start` then `npm run relay:setup`
    - Vite dev server: `cd lens-editor && npm run dev:local`

    **Test 1: Document with discussion field**
    1. Open the editor at http://dev.vps:5173 (or http://localhost:5173 on VPS)
    2. Edit a test document to add frontmatter: `discussion: https://discord.com/channels/YOUR_GUILD_ID/YOUR_CHANNEL_ID`
    3. Verify: A chat panel appears to the right showing messages from that Discord channel
    4. Verify: Each message shows an avatar image, username, and relative timestamp
    5. Verify: Messages are in chronological order (oldest at top, newest at bottom)
    6. Verify: The panel header shows the channel name with # prefix

    **Test 2: Document without discussion field**
    1. Open a document that has no `discussion` field in its frontmatter
    2. Verify: No chat panel appears -- the layout looks identical to before this feature

    **Test 3: Error handling**
    1. Stop the discord-bridge process
    2. Open a document with a discussion field
    3. Verify: Panel shows an error message with a "Retry" button
    4. Restart the discord-bridge
    5. Click "Retry"
    6. Verify: Messages load successfully

    **Test 4: Run integration smoke test (optional)**
    ```bash
    DISCORD_BOT_TOKEN=your-token DISCORD_TEST_CHANNEL_ID=your-channel-id npx vitest run src/components/DiscussionPanel/DiscussionPanel.integration.test.tsx
    ```
    Verify: Tests pass against the live sidecar.
  </how-to-verify>
  <resume-signal>Type "approved" if the panel works correctly, or describe any visual or functional issues.</resume-signal>
</task>

</tasks>

<verification>
```bash
# All DiscussionPanel tests pass
cd lens-editor && npx vitest run src/components/DiscussionPanel/

# TypeScript compiles clean
cd lens-editor && npx tsc --noEmit

# Full test suite passes (no regressions)
cd lens-editor && npx vitest run

# Build succeeds
cd lens-editor && npx vite build 2>&1 | tail -5
```
</verification>

<success_criteria>
- DiscussionPanel.test.tsx exists with tests covering: message rendering, avatars, usernames, timestamps, grouping, loading state, error state with retry, empty state, conditional rendering
- Tests use real Discord API fixture data from __fixtures__/ (not hand-crafted mocks)
- Tests mock only at fetch boundary (globalThis.fetch) and Y.Doc context -- everything else runs real
- DiscussionPanel.integration.test.tsx exists, gated by DISCORD_BOT_TOKEN env var, asserting structural invariants
- All unit tests pass
- Panel appears ONLY when document has `discussion` frontmatter field
- Panel shows channel name as header
- Messages show author avatar (with fallback), username (global_name preferred), and formatted timestamp
- Consecutive same-author messages within 5 minutes are visually grouped
- Panel integrates cleanly with existing EditorArea layout (no regressions to existing sidebar)
- All existing tests pass
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-bridge-history-display/01-03-SUMMARY.md`
</output>
