---
phase: 08-move-surfaces
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/relay/src/mcp/tools/move_doc.rs
  - crates/relay/src/mcp/tools/mod.rs
  - crates/relay/src/mcp/router.rs
autonomous: false

must_haves:
  truths:
    - "AI assistant can call the MCP move_document tool to relocate a document and receives confirmation of the new path"
    - "Move tool rejects missing/invalid parameters with clear error messages"
    - "Move tool rejects moves to paths that already exist (409 conflict)"
    - "Move tool rejects moves for unknown UUIDs (404 not found)"
    - "After MCP move, wikilinks in other documents are rewritten (full pipeline)"
  artifacts:
    - path: "crates/relay/src/mcp/tools/move_doc.rs"
      provides: "MCP move_document tool implementation"
      exports: ["execute"]
    - path: "crates/relay/src/mcp/tools/mod.rs"
      provides: "move_document tool definition and dispatch entry"
      contains: "move_doc"
    - path: "crates/relay/src/mcp/router.rs"
      provides: "Updated tool count in tests"
      contains: "7"
  key_links:
    - from: "crates/relay/src/mcp/tools/move_doc.rs"
      to: "link_indexer::move_document"
      via: "direct function call"
      pattern: "link_indexer::move_document"
    - from: "crates/relay/src/mcp/tools/mod.rs"
      to: "crates/relay/src/mcp/tools/move_doc.rs"
      via: "module declaration and dispatch match arm"
      pattern: "move_doc::execute"
---

<objective>
Add MCP move_document tool so AI assistants can move documents between and within folders.

Purpose: Satisfies requirement UI-05 -- AI assistants can relocate documents via MCP, with automatic backlink rewriting.
Output: New MCP tool `move_document` registered alongside existing 6 tools (total: 7).
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-move-api-backlink-rewriting/07-02-SUMMARY.md

@crates/relay/src/mcp/tools/mod.rs
@crates/relay/src/mcp/tools/grep.rs
@crates/relay/src/mcp/router.rs
@crates/relay/src/server.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MCP move_document tool</name>
  <files>
    crates/relay/src/mcp/tools/move_doc.rs
    crates/relay/src/mcp/tools/mod.rs
    crates/relay/src/mcp/router.rs
  </files>
  <action>
Create `crates/relay/src/mcp/tools/move_doc.rs` with `pub fn execute(server: &Arc<Server>, arguments: &Value) -> Result<String, String>`.

The tool accepts three parameters:
- `file_path` (required, string): Current document path in "Folder/path.md" format (e.g. "Lens/Biology/Photosynthesis.md")
- `new_path` (required, string): New path within the target folder, starting with "/" (e.g. "/Science/Photosynthesis.md")
- `target_folder` (optional, string): Target folder name for cross-folder moves (e.g. "Lens Edu"). Omit for within-folder moves.

Implementation approach -- replicate the synchronous block from `handle_move_document` in server.rs:

1. Resolve `file_path` to a UUID via `server.doc_resolver().resolve_path(&file_path)` to get `DocInfo` with uuid, folder_doc_id, etc.
2. If resolution fails, return Err("Document not found: {file_path}")
3. Validate `new_path` starts with "/" and ends with ".md", return Err on bad format
4. Find all folder doc IDs via `link_indexer::find_all_folder_docs(server.docs())`
5. Determine source and target folder indices (same logic as handle_move_document):
   - Source: the folder that contains the document (from DocInfo.folder_doc_id)
   - Target: if `target_folder` is provided, find the folder with matching name; otherwise same as source
6. Acquire awareness read guards for all folder docs, then write guards for source and target
7. Collect content doc UUIDs that might need wikilink rewriting (same backlinks_v0 scan as HTTP handler)
8. Call `link_indexer::move_document(uuid, new_path, source_doc, target_doc, all_folder_docs, all_folder_names, doc_resolver, content_docs)`
9. After the synchronous block, update search index via `search_handle_content_update` (this is synchronous, no .await needed)
10. Skip explicit persist and link indexer async notification -- Y.Doc changes propagate through SyncKv automatically
11. Return Ok with a formatted string: "Moved {old_path} -> {new_folder}/{new_path} ({links_rewritten} links rewritten)"

Error mapping:
- UUID not found -> "Document not found: {file_path}"
- Bad path format -> "new_path must start with '/' and end with '.md'"
- Unknown target folder -> "Unknown target folder: {name}. Available: {list}"
- Path conflict (move_document returns error) -> forward the anyhow error message
- Internal errors -> forward as-is

Key implementation notes:
- Use the same `sync block` pattern as handle_move_document to keep DashMap guards and awareness write locks from escaping the block. Even though dispatch_tool is sync (no .await points), keeping this pattern is good practice and consistent.
- Import `link_indexer` from `y_sweet_core` (same as server.rs does)
- Import `search_handle_content_update` from `crate::server` (make it pub if needed -- check if it already is)
- The `server.docs()` accessor returns &DashMap; use same iteration patterns as grep.rs and server.rs

In `crates/relay/src/mcp/tools/mod.rs`:
1. Add `pub mod move_doc;` to the module declarations
2. Add tool definition to `tool_definitions()`:
```json
{
  "name": "move_document",
  "description": "Move a document to a new path within the same folder or to a different folder. Automatically rewrites wikilinks in other documents that point to the moved file.",
  "inputSchema": {
    "type": "object",
    "required": ["file_path", "new_path", "session_id"],
    "additionalProperties": false,
    "properties": {
      "file_path": {
        "type": "string",
        "description": "Current path of the document (e.g. 'Lens/Biology/Photosynthesis.md')"
      },
      "new_path": {
        "type": "string",
        "description": "New path within the target folder, starting with '/' (e.g. '/Science/Photosynthesis.md')"
      },
      "target_folder": {
        "type": "string",
        "description": "Target folder for cross-folder moves (e.g. 'Lens Edu'). Omit to stay in the same folder."
      },
      "session_id": {
        "type": "string",
        "description": "Session ID from create_session. Required for all tool calls."
      }
    }
  }
}
```
3. Add dispatch match arm: `"move_document" => match move_doc::execute(server, arguments) { ... }`

In `crates/relay/src/mcp/router.rs`:
1. Update the `tools_list_returns_six_tools` test: rename to `tools_list_returns_seven_tools`, change `assert_eq!(tools_arr.len(), 6)` to `7`, add `assert!(names.contains(&"move_document"))`.

For `search_handle_content_update`: check if it's already `pub` in server.rs. If not, add `pub` visibility. It's used by the HTTP handler already, so making it pub for the MCP tool is the right pattern.
  </action>
  <verify>
Run `CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=/home/penguin/code/lens-relay/ws1/crates/Cargo.toml 2>&1 | tail -5` -- all tests pass including the updated tool count test.
Run `CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo build --manifest-path=/home/penguin/code/lens-relay/ws1/crates/Cargo.toml 2>&1 | tail -3` -- compiles without errors.
  </verify>
  <done>MCP move_document tool is registered as the 7th tool, compiles, and all existing tests pass. The tool accepts file_path + new_path + optional target_folder, calls move_document core, updates search index, and returns a confirmation string.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify MCP move_document tool with live server</name>
  <files>crates/relay/src/mcp/tools/move_doc.rs</files>
  <what-built>MCP move_document tool that moves documents and rewrites backlinks</what-built>
  <action>Human verification of the live MCP move_document tool.</action>
  <how-to-verify>
    1. Start local relay server: `cd /home/penguin/code/lens-relay/ws1/lens-editor && npm run relay:start` (if not already running)
    2. Set up test documents: `cd /home/penguin/code/lens-relay/ws1/lens-editor && npm run relay:setup`
    3. Test MCP move via curl (within-folder rename):
       ```
       curl -s http://localhost:8090/mcp -H 'Content-Type: application/json' -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","clientInfo":{"name":"test"}}}' | head -c 200
       ```
       Extract session_id from response, then:
       ```
       curl -s http://localhost:8090/mcp -H 'Content-Type: application/json' -H 'Mcp-Session-Id: SESSION_ID' -d '{"jsonrpc":"2.0","id":2,"method":"notifications/initialized"}'
       ```
       Then call move_document:
       ```
       curl -s http://localhost:8090/mcp -H 'Content-Type: application/json' -H 'Mcp-Session-Id: SESSION_ID' -d '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"move_document","arguments":{"file_path":"PATH","new_path":"/NewName.md","session_id":"SESSION_ID"}}}'
       ```
    4. Verify response contains old path, new path, and links_rewritten count
    5. Verify the document appears at the new path (use glob tool or GET /search)

    Note: If MCP_API_KEY is not set on local relay, MCP endpoint may not be registered. In that case, test via POST /doc/move directly to verify the core logic works, and verify MCP tool registration via cargo test.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
  <verify>Human verifies move tool returns confirmation string with old path, new path, and links_rewritten count.</verify>
  <done>MCP move_document tool works end-to-end with live relay server.</done>
</task>

</tasks>

<verification>
- `cargo test` passes with all existing + updated tests
- `cargo build` succeeds
- MCP tools/list returns 7 tools including move_document
- move_document tool definition has correct inputSchema
</verification>

<success_criteria>
AI assistant can call move_document MCP tool with file_path and new_path, receive confirmation of the move including old path, new path, and links rewritten count. The tool handles within-folder moves, cross-folder moves, and error cases (not found, bad format, conflict).
</success_criteria>

<output>
After completion, create `.planning/phases/08-move-surfaces/08-01-SUMMARY.md`
</output>
