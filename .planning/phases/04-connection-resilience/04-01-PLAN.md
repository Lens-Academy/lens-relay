---
phase: 04-connection-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - discord-bridge/src/gateway.ts
  - discord-bridge/src/index.ts
  - lens-editor/src/components/DiscussionPanel/useMessages.ts
  - lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx
  - lens-editor/src/components/DiscussionPanel/DiscussionPanel.test.tsx
autonomous: true

must_haves:
  truths:
    - "When the SSE connection drops, the status indicator changes from 'Live' to 'Reconnecting' or 'Disconnected' with visible text labels"
    - "When the Discord Gateway drops and reconnects, SSE clients are notified and the status indicator updates"
    - "When EventSource terminally closes, the UI shows 'Disconnected' with a retry button"
    - "When the SSE connection reconnects after a drop, message history is automatically reloaded to fill the gap"
    - "Clicking 'Retry' re-establishes the SSE connection and reloads message history without a full page reload"
    - "If no heartbeat is received for ~75 seconds, the status indicator changes to 'Reconnecting'"
  artifacts:
    - path: "discord-bridge/src/gateway.ts"
      provides: "Gateway lifecycle events emitted via gatewayEvents"
      contains: "gatewayEvents.emit.*status"
    - path: "discord-bridge/src/index.ts"
      provides: "SSE endpoint forwarding gateway status events to browser clients"
      contains: "gatewayEvents.on.*status"
    - path: "lens-editor/src/components/DiscussionPanel/useMessages.ts"
      provides: "SSE reconnection triggers refetch, heartbeat timeout detection, terminal disconnect handling"
      contains: "hasConnectedBefore|heartbeatTimer|EventSource.CLOSED"
    - path: "lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx"
      provides: "StatusIndicator component with text labels and retry affordance for disconnected state"
      contains: "StatusIndicator|Live|Reconnecting|Disconnected"
  key_links:
    - from: "discord-bridge/src/gateway.ts"
      to: "discord-bridge/src/index.ts"
      via: "gatewayEvents.emit('status') -> gatewayEvents.on('status')"
      pattern: "gatewayEvents\\.emit\\('status'"
    - from: "discord-bridge/src/index.ts"
      to: "lens-editor/src/components/DiscussionPanel/useMessages.ts"
      via: "stream.writeSSE event:'status' -> eventSource.addEventListener('status')"
      pattern: "addEventListener\\('status'"
    - from: "useMessages.ts"
      to: "DiscussionPanel.tsx"
      via: "gatewayStatus + error + refetch returned from hook -> StatusIndicator + retry UI"
      pattern: "gatewayStatus.*error.*refetch"
---

<objective>
Add connection resilience to the DiscussionPanel so users see clear status indicators ("Live", "Reconnecting", "Disconnected") and can recover from connection failures without a page reload.

Purpose: This completes Phase 4 (final phase), satisfying UX-02 (error state with retry) and UX-03 (connection status indicator). The existing code has the basic structure (GatewayStatus type, colored dots, error/retry UI) but is missing: gateway status broadcasting from bridge to SSE clients, automatic history reload on SSE reconnection, heartbeat timeout detection, terminal disconnect handling, and visible text labels on the status indicator.

Output: Enhanced gateway.ts, index.ts, useMessages.ts, and DiscussionPanel.tsx with full connection resilience behavior.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-connection-resilience/04-RESEARCH.md

Key source files to enhance:
@discord-bridge/src/gateway.ts
@discord-bridge/src/index.ts
@lens-editor/src/components/DiscussionPanel/useMessages.ts
@lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx
@lens-editor/src/components/DiscussionPanel/DiscussionPanel.test.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bridge-side gateway status broadcasting and SSE forwarding</name>
  <files>
    discord-bridge/src/gateway.ts
    discord-bridge/src/index.ts
  </files>
  <action>
**gateway.ts:** Add `gatewayEvents.emit('status', ...)` calls to the existing Discord.js event handlers so that gateway lifecycle changes are broadcast to SSE clients:

1. In `Events.ClientReady` handler: after the console.log, add `gatewayEvents.emit('status', { gateway: 'connected' });`
2. In `Events.ShardReconnecting` handler: after the console.log, add `gatewayEvents.emit('status', { gateway: 'reconnecting' });`
3. In `Events.ShardResume` handler: after the console.log, add `gatewayEvents.emit('status', { gateway: 'connected' });`
4. Add a NEW handler for `Events.ShardDisconnect`: log it and emit `gatewayEvents.emit('status', { gateway: 'disconnected' });`

**index.ts SSE endpoint:** Inside the `streamSSE` callback, AFTER the existing `handler` setup for channel messages, add a status event handler that forwards gateway status changes to the SSE client:

```typescript
const statusHandler = async (data: unknown) => {
  try {
    await stream.writeSSE({
      event: 'status',
      data: JSON.stringify(data),
    });
  } catch {
    // Client disconnected
  }
};
gatewayEvents.on('status', statusHandler);
```

Update the existing `stream.onAbort` cleanup to ALSO remove the status handler:
```typescript
stream.onAbort(() => {
  gatewayEvents.off(`message:${channelId}`, handler);
  gatewayEvents.off('status', statusHandler);
});
```

This ensures that when the Discord Gateway drops/reconnects, ALL connected SSE browser clients are notified in real time.
  </action>
  <verify>
    Run `cd /home/penguin/code/lens-relay/ws1/discord-bridge && npx tsc --noEmit` to verify TypeScript compiles without errors. Grep for `gatewayEvents.emit('status'` in gateway.ts to confirm 4 emit calls. Grep for `gatewayEvents.on('status'` in index.ts to confirm the forwarding handler.
  </verify>
  <done>
    gateway.ts emits 'status' events on ClientReady, ShardReconnecting, ShardResume, and ShardDisconnect. index.ts SSE endpoint forwards these status events to connected browser clients and cleans up the listener on abort.
  </done>
</task>

<task type="auto">
  <name>Task 2: Client-side reconnection, heartbeat timeout, terminal disconnect, and status UI</name>
  <files>
    lens-editor/src/components/DiscussionPanel/useMessages.ts
    lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx
    lens-editor/src/components/DiscussionPanel/DiscussionPanel.test.tsx
  </files>
  <action>
**useMessages.ts** - Enhance the SSE useEffect with three capabilities:

1. **Reconnection history reload:** Add a `let hasConnectedBefore = false;` local variable. In `eventSource.onopen`, after setting status to `'connected'`, check if `hasConnectedBefore` is true. If so, call `setFetchTrigger((t) => t + 1)` to reload message history (fills the gap from disconnection). Then set `hasConnectedBefore = true`. Also clear any error: `setError(null)`.

2. **Heartbeat timeout detection:** Add a `let heartbeatTimer: ReturnType<typeof setTimeout>;` local variable and a `HEARTBEAT_TIMEOUT_MS = 75_000` constant (2.5x the 30s heartbeat interval). Create a `resetHeartbeat()` function that clears the existing timer and sets a new one that calls `setGatewayStatus('reconnecting')` on timeout. Call `resetHeartbeat()` from: `eventSource.onopen`, the `message` event listener, the `status` event listener, and the `heartbeat` event listener. Clear the timer in the cleanup function alongside `eventSource.close()`.

3. **Terminal disconnect detection:** In `eventSource.onerror`, check `eventSource.readyState === EventSource.CLOSED`. If CLOSED: set status to `'disconnected'`, set error to `'Connection lost'`, and clear the heartbeat timer. If NOT CLOSED (readyState is CONNECTING, meaning auto-reconnecting): set status to `'reconnecting'` and clear the heartbeat timer.

**IMPORTANT stale closure avoidance:** Do NOT capture `refetch` in the SSE useEffect. Use `setFetchTrigger((t) => t + 1)` directly, which is a state updater function and immune to stale closures. The SSE useEffect should still only depend on `[channelId]`.

**DiscussionPanel.tsx** - Replace the inline status dots in the header with a `StatusIndicator` component:

1. Create a local `StatusIndicator` component (not exported, defined in the same file):
   - `connected` -> green dot + "Live" text (text-xs text-green-600)
   - `connecting` / `reconnecting` -> yellow pulsing dot + "Reconnecting" text (text-xs text-yellow-600)
   - `disconnected` -> gray dot + "Disconnected" text (text-xs text-gray-500)

2. Replace the 4 conditional `<span>` elements in the header with `<StatusIndicator status={gatewayStatus} />`.

3. Add a disconnected retry affordance: When `gatewayStatus === 'disconnected'` AND there is NO existing `error` (i.e., messages loaded fine but SSE died), show a small banner below the header with "Connection lost" text and a "Reconnect" button. The reconnect button should call `refetch()` which reloads messages. For the SSE reconnection itself, the simplest approach is: the retry clears the error and calls refetch, and the component can be enhanced to detect the disconnected state. However, since EventSource CLOSED state means the browser won't auto-reconnect, we need to recreate the EventSource. To do this cleanly:
   - Add a new state `sseReconnectTrigger` (number, starts at 0) to `useMessages.ts`
   - Add it as a dependency to the SSE useEffect alongside `channelId`: `[channelId, sseReconnectTrigger]`
   - Export a `reconnect` function from `useMessages` that increments `sseReconnectTrigger` and also triggers a refetch
   - In DiscussionPanel, the "Reconnect" button calls `reconnect()`
   - Update the `UseMessagesResult` interface to include `reconnect: () => void`

4. Update the error state UI: When `error` is set AND `gatewayStatus === 'disconnected'`, show both the error message and a "Reconnect" button (not just "Retry"). When error is set but status is not disconnected (REST fetch failure), keep showing "Retry" calling `refetch`.

**DiscussionPanel.test.tsx** - Add tests for connection resilience behavior:

1. Enhance MockEventSource to support test helpers: add `_simulateError()` (sets readyState to CONNECTING, fires onerror), `_simulateTerminalError()` (sets readyState to CLOSED, fires onerror), `_simulateReconnect()` (sets readyState to OPEN, fires onopen), `_simulateEvent(type, data)` (creates MessageEvent and fires listeners). Add `static instances: MockEventSource[]` tracking and `static getLastInstance()`. Add `static clearInstances()`.

2. Add test: "shows 'Live' text when connected" -- render with valid doc, wait for fetch, advance timer to fire onopen, assert `screen.getByText('Live')` exists.

3. Add test: "shows 'Reconnecting' text on transient SSE error" -- render, wait for connected state, call `_simulateError()` on the instance, assert `screen.getByText('Reconnecting')` exists.

4. Add test: "shows 'Disconnected' text on terminal SSE error" -- render, wait for connected state, call `_simulateTerminalError()`, assert `screen.getByText('Disconnected')` exists.

5. Add test: "shows Reconnect button on terminal disconnect" -- render, wait for connected, terminal error, assert `screen.getByRole('button', { name: /reconnect/i })` exists.

6. Clean up MockEventSource.instances in afterEach with `MockEventSource.clearInstances()`.
  </action>
  <verify>
    Run `cd /home/penguin/code/lens-relay/ws1/lens-editor && npx vitest run src/components/DiscussionPanel/DiscussionPanel.test.tsx` to verify all existing and new tests pass. Run `npx tsc --noEmit` to verify TypeScript compiles. Verify the text "Live", "Reconnecting", "Disconnected" appears in DiscussionPanel.tsx via grep.
  </verify>
  <done>
    useMessages.ts handles SSE reconnection with history reload, heartbeat timeout detection (75s), and terminal disconnect detection. DiscussionPanel.tsx shows text-labeled status indicator ("Live"/"Reconnecting"/"Disconnected") and a "Reconnect" button when terminally disconnected. Tests cover connected, reconnecting, and disconnected states. The `reconnect` function recreates the EventSource for terminal CLOSED state recovery.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/penguin/code/lens-relay/ws1/discord-bridge && npx tsc --noEmit` -- bridge compiles
2. `cd /home/penguin/code/lens-relay/ws1/lens-editor && npx tsc --noEmit` -- editor compiles
3. `cd /home/penguin/code/lens-relay/ws1/lens-editor && npx vitest run src/components/DiscussionPanel/DiscussionPanel.test.tsx` -- all tests pass
4. Grep for "Live" and "Reconnecting" and "Disconnected" in DiscussionPanel.tsx -- all three labels present
5. Grep for `gatewayEvents.emit('status'` in gateway.ts -- 4 occurrences (ClientReady, ShardReconnecting, ShardResume, ShardDisconnect)
6. Grep for `heartbeatTimer` in useMessages.ts -- timeout detection implemented
7. Grep for `EventSource.CLOSED` in useMessages.ts -- terminal disconnect handled
8. Grep for `hasConnectedBefore` in useMessages.ts -- reconnection refetch implemented
</verification>

<success_criteria>
- Status indicator shows visible text: "Live" (green), "Reconnecting" (yellow, pulsing), "Disconnected" (gray)
- Gateway lifecycle events (connect, reconnect, disconnect) are broadcast from bridge to browser via SSE
- SSE reconnection automatically reloads message history to fill gaps
- Heartbeat timeout (75s) triggers "Reconnecting" status when connection goes stale
- Terminal EventSource.CLOSED state shows "Disconnected" with a "Reconnect" button
- Clicking "Reconnect" recreates the EventSource and reloads messages without page reload
- All existing tests continue to pass alongside new connection resilience tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-connection-resilience/04-01-SUMMARY.md`
</output>
