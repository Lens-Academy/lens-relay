---
phase: 07-move-api-backlink-rewriting
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/y-sweet-core/src/link_indexer.rs
autonomous: true

must_haves:
  truths:
    - "A document moved within the same folder has its filemeta_v0 path key updated (old removed, new inserted with same UUID)"
    - "A document moved across folders is removed from source filemeta_v0 and added to target filemeta_v0"
    - "All three indexes (DocumentResolver, SearchIndex, link index) reflect the new path after a move"
    - "Wikilinks in backlinker documents that pointed to the moved document's old name are rewritten to the new name"
    - "Active editors remain connected (UUID unchanged, only filemeta path key changes)"
  artifacts:
    - path: "crates/y-sweet-core/src/link_indexer.rs"
      provides: "move_document() core function + within-folder and cross-folder move logic"
      contains: "pub fn move_document"
  key_links:
    - from: "move_document"
      to: "filemeta_v0 Y.Map"
      via: "transact_mut to remove old path key and insert new path key"
      pattern: "filemeta\\.remove.*filemeta\\.insert"
    - from: "move_document"
      to: "update_wikilinks_in_doc_resolved"
      via: "backlink lookup + wikilink rewriting per backlinker"
      pattern: "update_wikilinks_in_doc_resolved"
    - from: "move_document"
      to: "DocumentResolver::upsert_doc"
      via: "index cascade after filemeta update"
      pattern: "upsert_doc"
---

<objective>
Implement the core `move_document` function that performs a document move operation on bare Y.Docs: updates filemeta_v0 (path key swap), cascades to all three indexes, and rewrites wikilinks in backlinker documents.

Purpose: This is the business logic for file moves, tested in isolation against bare Y.Docs without needing a running server. Phase 7 Plan 02 will wire this into an HTTP endpoint.

Output: A tested `move_document()` function in `link_indexer.rs` that handles within-folder moves, cross-folder moves, and automatic wikilink rewriting.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-generic-index-updates/06-01-SUMMARY.md
@crates/y-sweet-core/src/link_indexer.rs
@crates/y-sweet-core/src/doc_resolver.rs
@crates/y-sweet-core/src/search_index.rs
@crates/y-sweet-core/src/link_parser.rs
</context>

<feature>
  <name>move_document core function</name>
  <files>crates/y-sweet-core/src/link_indexer.rs</files>
  <behavior>
    The function `move_document()` operates on bare Y.Docs (no DocWithSyncKv, no async).

    Signature:
    ```rust
    pub fn move_document(
        uuid: &str,
        new_path: &str,           // New filemeta path, e.g. "/Biology/Photosynthesis.md"
        source_folder_doc: &Doc,  // Folder doc containing the document
        target_folder_doc: &Doc,  // Same as source for within-folder, different for cross-folder
        all_folder_docs: &[&Doc], // All folder docs for virtual tree building + backlink scanning
        all_folder_names: &[&str], // Folder names corresponding to all_folder_docs
        doc_resolver: &DocumentResolver,
        content_docs: &std::collections::HashMap<String, &Doc>, // uuid -> content Y.Doc for wikilink editing
    ) -> anyhow::Result<MoveResult>
    ```

    MoveResult struct:
    ```rust
    pub struct MoveResult {
        pub old_path: String,       // Previous filemeta path (e.g. "/Photosynthesis.md")
        pub new_path: String,       // New filemeta path
        pub old_folder_name: String,
        pub new_folder_name: String,
        pub links_rewritten: usize, // Total wikilink edits across all backlinker docs
    }
    ```

    Steps:
    1. Find the UUID in source_folder_doc's filemeta_v0, extract old path + metadata entry
    2. If source == target (within-folder move):
       - Remove old path key, insert new path key with same metadata, in one transaction
    3. If source != target (cross-folder move):
       - Remove from source filemeta_v0 (transact_mut)
       - Insert into target filemeta_v0 (transact_mut)
    4. Update DocumentResolver: call `upsert_doc()` with new full path ("{folder_name}/{stripped_path}")
       - For cross-folder: also update folder_name, folder_doc_id in DocInfo
    5. Build virtual entries from all folder docs (using build_virtual_entries or inline)
       - Patch entries to reflect OLD paths for resolution (same pattern as apply_rename_updates)
    6. Read backlinks for the moved UUID from all folder docs' backlinks_v0
    7. For each backlinker UUID: find its content doc, call update_wikilinks_in_doc_resolved()
       with old basename -> new basename
    8. Re-index the moved doc's backlinks (its wikilinks may resolve differently at new location)

    Test cases (input -> expected output):
    1. Within-folder move: "/Photosynthesis.md" -> "/Biology/Photosynthesis.md"
       - Old path removed from filemeta, new path present
       - DocumentResolver resolves new path, old path returns None
       - UUID unchanged
    2. Within-folder rename: "/Photosynthesis.md" -> "/Photosynthesis_v2.md"
       - Backlinker with [[Photosynthesis]] gets rewritten to [[Photosynthesis_v2]]
    3. Cross-folder move: Lens "/Photosynthesis.md" -> Lens Edu "/Photosynthesis.md"
       - Source filemeta no longer has entry, target filemeta has it
       - DocumentResolver path changes from "Lens/Photosynthesis.md" to "Lens Edu/Photosynthesis.md"
    4. Move with no backlinkers: links_rewritten == 0, no errors
    5. Move preserves UUID: uuid_to_path returns new path, same UUID
    6. Wikilink rewriting with anchors/aliases: [[Photosynthesis#Section]] becomes [[NewName#Section]]
  </behavior>
  <implementation>
    Add `move_document()` as a pub free function in `link_indexer.rs` alongside the existing
    `update_wikilinks_in_doc` and `remove_doc_from_backlinks` functions (in the "Wikilink rename"
    or a new "Document move" section).

    Add `MoveResult` struct near the top of the file with the other public types.

    Key implementation details:
    - Use `transact_mut_with("link-indexer")` for all Y.Doc mutations (consistent with existing code)
    - For filemeta entry transfer: extract the full metadata value (id, type, version) from old path,
      insert it at new path. Use `extract_id_from_filemeta_entry` pattern but preserve the full value.
      Since filemeta entries are `Out::YMap(MapRef)` or `Out::Any(Any::Map)`, read all fields and
      reconstruct as `Any::Map` for the insert.
    - The existing `update_wikilinks_in_doc_resolved()` and `build_virtual_entries()` functions
      handle all the wikilink rewriting complexity -- reuse them.
    - `detect_renames` and `apply_rename_updates` do something similar for live renames detected
      from filemeta diffs. The move function is the explicit/API version of the same operation.

    The function does NOT handle SearchIndex updates -- that requires the content doc's text,
    which the caller (HTTP handler) can do after calling move_document. The function DOES update
    DocumentResolver since it receives it as a parameter.

    Test helpers: Reuse existing `create_folder_doc`, `set_folder_name`, `build_resolver` from
    doc_resolver tests. Add `create_content_doc(text: &str) -> Doc` helper that creates a Y.Doc
    with Y.Text("contents").
  </implementation>
</feature>

<verification>
```bash
# Run only link_indexer tests (includes new move tests)
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/Cargo.toml -p y-sweet-core -- link_indexer::tests::move_
```

Expected: All new `move_*` tests pass (6+ tests covering the cases above).

```bash
# Full test suite still passes
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/Cargo.toml
```
</verification>

<success_criteria>
- `move_document()` function exists in `link_indexer.rs` and is `pub`
- `MoveResult` struct exists and is `pub`
- At least 6 tests cover: within-folder move, within-folder rename with backlink rewrite, cross-folder move, no-backlinkers case, UUID preservation, anchor/alias preservation
- All tests pass including existing 300+ tests
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/07-move-api-backlink-rewriting/07-01-SUMMARY.md`
</output>
