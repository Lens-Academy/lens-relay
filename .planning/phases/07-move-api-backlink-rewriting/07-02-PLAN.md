---
phase: 07-move-api-backlink-rewriting
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - crates/relay/src/server.rs
autonomous: false

must_haves:
  truths:
    - "POST /doc/move with uuid and new_path returns 200 and the document is accessible at the new path"
    - "Cross-folder move (Lens to Lens Edu) via the endpoint removes doc from source folder and adds to target"
    - "After a move via the endpoint, the search index reflects the new title/path"
    - "An editor with the document open before the move remains connected and can continue editing"
  artifacts:
    - path: "crates/relay/src/server.rs"
      provides: "handle_move_document HTTP handler + route registration"
      contains: "handle_move_document"
  key_links:
    - from: "handle_move_document"
      to: "move_document()"
      via: "unwraps DocWithSyncKv -> bare Y.Doc, calls core function"
      pattern: "link_indexer::move_document"
    - from: "routes()"
      to: "handle_move_document"
      via: "axum .route() registration"
      pattern: "route.*move.*post.*handle_move_document"
---

<objective>
Wire the core `move_document()` function into an HTTP endpoint and verify the full pipeline works with a running relay server.

Purpose: Makes file moves accessible to HTTP callers (lens-editor UI, MCP tool, curl). Adds the server-side glue that unwraps DocWithSyncKv, calls the core function, updates SearchIndex, and returns a JSON response.

Output: `POST /doc/move` endpoint that accepts `{uuid, new_path, target_folder?}` and returns `{old_path, new_path, old_folder, new_folder, links_rewritten}`.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-move-api-backlink-rewriting/07-01-SUMMARY.md
@crates/relay/src/server.rs
@crates/y-sweet-core/src/link_indexer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add POST /doc/move endpoint</name>
  <files>crates/relay/src/server.rs</files>
  <action>
    Add the `handle_move_document` async handler function and register it as a route.

    1. Define request/response types:
    ```rust
    #[derive(Deserialize)]
    struct MoveDocRequest {
        uuid: String,
        new_path: String,           // New filemeta path, e.g. "/Biology/Photosynthesis.md"
        target_folder: Option<String>, // Target folder name for cross-folder moves (e.g. "Lens Edu")
    }

    #[derive(Serialize)]
    struct MoveDocResponse {
        old_path: String,
        new_path: String,
        old_folder: String,
        new_folder: String,
        links_rewritten: usize,
    }
    ```

    2. Implement `handle_move_document`:
    - Extract `MoveDocRequest` from JSON body
    - Find which folder doc currently contains the UUID (scan all folder docs' filemeta_v0)
    - If `target_folder` is specified, find the target folder doc by matching folder_config.name
    - If `target_folder` is None, target = source (within-folder move)
    - Unwrap DocWithSyncKv for all folder docs and content docs (backlinkers) into bare Y.Docs
      - Use awareness().write() for folder docs (need mutation)
      - Use awareness().write() for content docs (wikilink rewriting mutates them)
    - Call `link_indexer::move_document()` with bare Y.Docs
    - After move: update SearchIndex for the moved document (re-index with new title/folder)
    - Trigger link indexer on_document_update for the source folder doc (so background worker
      picks up the filemeta change and re-caches it, preventing false rename detection)
    - Return MoveDocResponse

    3. Register route in `routes()`:
    ```rust
    .route("/doc/move", post(handle_move_document))
    ```
    Add it near the other `/doc/` routes (after line ~1448).

    Important locking notes:
    - Must drop DashMap guards before acquiring awareness locks to avoid deadlocks
    - Process folder docs one at a time (same pattern as `apply_rename_updates`)
    - The move_document function operates on bare Y.Docs, so unwrap once and pass refs

    Error cases to handle:
    - UUID not found in any folder doc -> 404
    - Target folder not found -> 400
    - new_path already exists in target folder -> 409 Conflict
    - Invalid path format (must start with "/", must end with ".md") -> 400
  </action>
  <verify>
    ```bash
    CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo build --manifest-path=crates/Cargo.toml --bin relay
    ```
    Build succeeds without errors.
  </verify>
  <done>
    POST /doc/move endpoint compiles and is registered in the router. Request/response types defined. Error cases handled with appropriate HTTP status codes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify move endpoint with live server</name>
  <files>crates/relay/src/server.rs</files>
  <what-built>
    POST /doc/move HTTP endpoint for moving documents within and across folders, with automatic wikilink rewriting and index updates.
  </what-built>
  <action>Human verification of the live move endpoint.</action>
  <how-to-verify>
    1. Start the relay server:
       ```bash
       CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo run --manifest-path=crates/Cargo.toml --bin relay -- serve --port 8090
       ```
    2. Set up test data:
       ```bash
       cd lens-editor && npm run relay:setup
       ```
    3. Verify a document exists at its current path by checking the search endpoint:
       ```bash
       curl -s http://localhost:8090/search?q=photosynthesis | jq .
       ```
    4. Test within-folder move:
       ```bash
       # Find a document UUID from the search results
       # Move it to a new path within the same folder
       curl -s -X POST http://localhost:8090/doc/move \
         -H "Content-Type: application/json" \
         -d '{"uuid":"<uuid>","new_path":"/Biology/Photosynthesis.md"}' | jq .
       ```
       Expected: 200 with old_path, new_path, folder info
    5. Verify search index updated:
       ```bash
       curl -s http://localhost:8090/search?q=photosynthesis | jq .
       ```
       Should show updated title reflecting new path.
    6. Open an editor link (from relay:setup output) to verify documents still load correctly.
  </how-to-verify>
  <verify>Human verifies move endpoint returns correct response and indexes are updated.</verify>
  <done>Move endpoint works for within-folder and cross-folder moves; search index reflects new paths; editors remain connected.</done>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `cargo build` succeeds for the relay binary
2. POST /doc/move returns 200 for valid within-folder move
3. POST /doc/move returns 200 for valid cross-folder move
4. Search index reflects new path after move
5. DocumentResolver resolves new path, old path returns 404
6. Full test suite passes (existing tests unbroken)
</verification>

<success_criteria>
- POST /doc/move endpoint accepts JSON request and returns JSON response
- Within-folder moves update filemeta_v0 + all indexes
- Cross-folder moves transfer between folder docs + update all indexes
- Wikilinks in backlinker docs are automatically rewritten
- Error cases return appropriate HTTP status codes (400, 404, 409)
- Editors connected via WebSocket remain connected during move (UUID unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/07-move-api-backlink-rewriting/07-02-SUMMARY.md`
</output>
